<body>
  <div id="container"></div>
</body>




<script src="http://threejs.org/build/three.min.js"></script>

<script src="http://threejs.org/examples/js/Detector.js"></script>

<script type="x-shader/x-vertex" id="vertexShader">



    varying vec3 vWorldPosition;

    void main() {

      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vWorldPosition = worldPosition.xyz;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

  </script>

  <script type="x-shader/x-fragment" id="fragmentShader">

    uniform vec3 topColor;
    uniform vec3 bottomColor;
    uniform float offset;
    uniform float exponent;

    varying vec3 vWorldPosition;

    void main() {

      float h = normalize( vWorldPosition + offset ).y;
      gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

    }

  </script>

  <script>

    if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

    var camera, scene, renderer, dirLight, hemiLight;
    var mixers = [];

    var clock = new THREE.Clock();

    init();
    animate();

    function init() {

      var container = document.getElementById( 'container' );

      camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );
      camera.position.set( 0, 0, 250 );

      scene = new THREE.Scene();

      scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
      scene.fog.color.setHSL( 0.6, 0, 1 );

      // LIGHTS

      hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
      hemiLight.color.setHSL( 0.6, 1, 0.5);
      hemiLight.groundColor.setHSL( 0.86, 0.93, 0.1 );
      hemiLight.position.set( 0, 500, 0 );
      scene.add( hemiLight );

      //

      dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
      dirLight.color.setHSL( 0.1, 1, 0.95 );
      dirLight.position.set( -1, 1.75, 1 );
      dirLight.position.multiplyScalar( 50 );
      scene.add( dirLight );

      dirLight.castShadow = true;

      dirLight.shadow.mapSize.width = 2048;
      dirLight.shadow.mapSize.height = 2048;

      var d = 50;

      dirLight.shadow.camera.left = -d;
      dirLight.shadow.camera.right = d;
      dirLight.shadow.camera.top = d;
      dirLight.shadow.camera.bottom = -d;

      dirLight.shadow.camera.far = 3500;
      dirLight.shadow.bias = -0.0001;


      var particlesArray = [];
      backGroundies = new THREE.Geometry();
      for ( i = 0; i < 2000; i ++ ) {
        var vertex = new THREE.Vector3();
        vertex.x = 1000 * Math.random() - 500;
        vertex.y = 1000 * Math.random() - 500;
        vertex.z = 1000 * Math.random() - 500;
        backGroundies.vertices.push( vertex );
      }
      material = new THREE.ParticleBasicMaterial( { size: 1, sizeAttenuation: false, transparent: true } );
      material.color.setHex( 0x99FFFF );
      particles = new THREE.ParticleSystem( backGroundies, material );
      particles.sortParticles = true;
      scene.add( particles );
      particlesArray.push( particles );

      // GROUND

      var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
      var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
      groundMat.color.setHSL( 0, 1, 0.15 );

      var ground = new THREE.Mesh( groundGeo, groundMat );
      ground.rotation.x = -Math.PI/2;
      ground.position.y = -33;
      scene.add( ground );

      ground.receiveShadow = true;

      // SKYDOME

      var vertexShader = document.getElementById( 'vertexShader' ).textContent;
      var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
      var uniforms = {
        topColor:    { value: new THREE.Color( 0x0173ff ) },
        bottomColor: { value: new THREE.Color( 0xff9c00 ) },
        offset:      { value: 33 },
        exponent:    { value: 0.6 }
      };
      uniforms.topColor.value.copy( hemiLight.color );

      scene.fog.color.copy( uniforms.bottomColor.value );

      var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
      var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

      var sky = new THREE.Mesh( skyGeo, skyMat );
      scene.add( sky );



      // RENDERER

      renderer = new THREE.WebGLRenderer( { antialias: true } );
      renderer.setClearColor( scene.fog.color );
      renderer.setPixelRatio( window.devicePixelRatio );
      renderer.setSize( window.innerWidth, window.innerHeight );
      container.appendChild( renderer.domElement );

      renderer.gammaInput = true;
      renderer.gammaOutput = true;

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.renderReverseSided = false;


      window.addEventListener( 'resize', onWindowResize, false );
      document.addEventListener( 'keydown', onKeyDown, false );

    }

    function onWindowResize() {

      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();

      renderer.setSize( window.innerWidth, window.innerHeight );

    }

    function onKeyDown ( event ) {

      switch ( event.keyCode ) {

        case 72: // h

        hemiLight.visible = !hemiLight.visible;
        break;

        case 68: // d

        dirLight.visible = !dirLight.visible;
        break;

      }

    }

    //

    function animate() {

      requestAnimationFrame( animate );

      render();

    }

    function render() {

      var delta = clock.getDelta();

      for ( var i = 0; i < mixers.length; i ++ ) {

        mixers[ i ].update( delta );

      }

      renderer.render( scene, camera );

    }

  </script>
