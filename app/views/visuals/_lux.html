
  <body>

    <div id="container"></div>
  </body>




    <script src="http://threejs.org/build/three.min.js"></script>

    <script src="http://threejs.org/examples/js/Detector.js"></script>


    <script src="http://threejs.org/examples/js/libs/stats.min.js"></script>


    <script type="x-shader/x-vertex" id="vertexShader">



      varying vec3 vWorldPosition;

      void main() {

        vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
        vWorldPosition = worldPosition.xyz;

        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

      }

    </script>

    <script type="x-shader/x-fragment" id="fragmentShader">

      uniform vec3 topColor;
      uniform vec3 bottomColor;
      uniform float offset;
      uniform float exponent;

      varying vec3 vWorldPosition;

      void main() {

        float h = normalize( vWorldPosition + offset ).y;
        gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

      }

    </script>

    <script>

      if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

      var camera, scene, renderer, dirLight, hemiLight, splineCamera, cameraHelper, cameraEye;
      var text, plane;
      var targetRotation = 0;
      var targetRotationOnMouseDown = 0;
      var mouseX = 0;
      var mouseXOnMouseDown = 0;
      var windowHalfX = window.innerWidth / 2;
      var windowHalfY = window.innerHeight / 2;
      var binormal = new THREE.Vector3();
      var normal = new THREE.Vector3();
      var stats;

      var pipeSpline = new THREE.CatmullRomCurve3( [
        new THREE.Vector3( 0, 10, -10 ), new THREE.Vector3( 10, 0, -10 ),
        new THREE.Vector3( 20, 0, 0 ), new THREE.Vector3( 30, 0, 10 ),
        new THREE.Vector3( 30, 0, 20 ), new THREE.Vector3( 20, 0, 30 ),
        new THREE.Vector3( 10, 0, 30 ), new THREE.Vector3( 0, 0, 30 ),
        new THREE.Vector3( -10, 10, 30 ), new THREE.Vector3( -10, 20, 30 ),
        new THREE.Vector3( 0, 30, 30 ), new THREE.Vector3( 10, 30, 30 ),
        new THREE.Vector3( 20, 30, 15 ), new THREE.Vector3( 10, 30, 10 ),
        new THREE.Vector3( 0, 30, 10 ), new THREE.Vector3( -10, 20, 10 ),
        new THREE.Vector3( -10, 10, 10 ), new THREE.Vector3( 0, 0, 10 ),
        new THREE.Vector3( 10, -10, 10 ), new THREE.Vector3( 20, -15, 10 ),
        new THREE.Vector3( 30, -15, 10 ), new THREE.Vector3( 40, -15, 10 ),
        new THREE.Vector3( 50, -15, 10 ), new THREE.Vector3( 60, 0, 10 ),
        new THREE.Vector3( 70, 0, 0 ), new THREE.Vector3( 80, 0, 0 ),
        new THREE.Vector3( 90, 0, 0 ), new THREE.Vector3( 100, 0, 0 )
      ] );

      var sampleClosedSpline = new THREE.CatmullRomCurve3( [
        new THREE.Vector3( 0, -40, -40 ),
        new THREE.Vector3( 0, 40, -40 ),
        new THREE.Vector3( 0, 140, -40 ),
        new THREE.Vector3( 0, 40, 40 ),
        new THREE.Vector3( 0, -40, 40 ),
      ] );

      var spline = TorusKnot: new THREE.Curves.TorusKnot( 20 );

      var closed2 = true;
      var parent;
      var tube, tubeMesh;
      var animation = false, lookAhead = false;
      var scale;
      var showCameraHelper = false;


		function addTube() {
			var value = document.getElementById( 'dropdown' ).value;
			var segments = parseInt( document.getElementById( 'segments' ).value );
			closed2 = document.getElementById( 'closed' ).checked;
			var radiusSegments = parseInt( document.getElementById( 'radiusSegments' ).value );
			if ( tubeMesh !== undefined ) parent.remove( tubeMesh );
			extrudePath = splines[ value ];
			tube = new THREE.TubeBufferGeometry( extrudePath, segments, 2, radiusSegments, closed2 );
			addGeometry( tube, 0xff00ff );
			setScale();
		}
		function setScale() {
			scale = parseInt( document.getElementById( 'scale' ).value );
			tubeMesh.scale.set( scale, scale, scale );
		}
		function addGeometry( geometry, color ) {
			// 3d shape
			tubeMesh = THREE.SceneUtils.createMultiMaterialObject( geometry, [
				new THREE.MeshLambertMaterial( {
					color: color
				} ),
				new THREE.MeshBasicMaterial( {
					color: 0x000000,
					opacity: 0.3,
					wireframe: true,
					transparent: true
			} ) ] );
			parent.add( tubeMesh );
		}
		function animateCamera( toggle ) {
			if ( toggle === true ) {
				animation = animation === false;
				document.getElementById( 'animation' ).value = 'Camera Spline Animation View: ' + ( animation ? 'ON' : 'OFF' );
			}
			lookAhead = document.getElementById( 'lookAhead' ).checked;
			showCameraHelper = document.getElementById( 'cameraHelper' ).checked;
			cameraHelper.visible = showCameraHelper;
			cameraEye.visible = showCameraHelper;
		}

    init();
    animate();


      var clock = new THREE.Clock();

      init();
      animate();

      function init() {

        var container = document.getElementById( 'container' );

        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000 );
        camera.position.set( 0, 0, 250 );

        scene = new THREE.Scene();

        scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
        scene.fog.color.setHSL( 0.6, 0, 1 );


			  parent = new THREE.Object3D();
		 	  scene.add( parent );
			  splineCamera = new THREE.PerspectiveCamera( 84, window.innerWidth / window.innerHeight, 0.01, 1000 );
			 parent.add( splineCamera );
			    cameraHelper = new THREE.CameraHelper( splineCamera );
			         scene.add( cameraHelper );
			addTube();

      cameraEye = new THREE.Mesh( new THREE.SphereGeometry( 5 ), new THREE.MeshBasicMaterial( { color: 0xdddddd } ) );
parent.add( cameraEye );
cameraHelper.visible = showCameraHelper;
cameraEye.visible = showCameraHelper;

        // LIGHTS

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
        hemiLight.color.setHSL( 0.6, 1, 0.6 );
        hemiLight.groundColor.setHSL( 0.095, 1, 0.75 );
        hemiLight.position.set( 0, 500, 0 );
        scene.add( hemiLight );

        //

        dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
        dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( -1, 1.75, 1 );
        dirLight.position.multiplyScalar( 50 );
        scene.add( dirLight );

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        var d = 50;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        dirLight.shadow.camera.far = 3500;
        dirLight.shadow.bias = -0.0001;

        // GROUND

        var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
        var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
        groundMat.color.setHSL( 0.095, 1, 0.75 );

        var ground = new THREE.Mesh( groundGeo, groundMat );
        ground.rotation.x = -Math.PI/2;
        ground.position.y = -33;
        scene.add( ground );

        ground.receiveShadow = true;

        // SKYDOME

        var vertexShader = document.getElementById( 'vertexShader' ).textContent;
        var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
        var uniforms = {
          topColor:    { value: new THREE.Color( 0x0077ff ) },
          bottomColor: { value: new THREE.Color( 0xffffff ) },
          offset:      { value: 33 },
          exponent:    { value: 0.6 }
        };
        uniforms.topColor.value.copy( hemiLight.color );

        scene.fog.color.copy( uniforms.bottomColor.value );

        var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
        var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

        var sky = new THREE.Mesh( skyGeo, skyMat );
        scene.add( sky );

        // RENDERER

        renderer = new THREE.WebGLRenderer( { antialias: true } );
        renderer.setClearColor( scene.fog.color );
        renderer.setPixelRatio( window.devicePixelRatio );
        renderer.setSize( window.innerWidth, window.innerHeight );
        container.appendChild( renderer.domElement );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.renderReverseSided = false;

        // STATS

        stats = new Stats();
        container.appendChild( stats.dom );

        //

        window.addEventListener( 'resize', onWindowResize, false );
        document.addEventListener( 'keydown', onKeyDown, false );

      }

      function onWindowResize() {

        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize( window.innerWidth, window.innerHeight );

      }

      function onKeyDown ( event ) {

        switch ( event.keyCode ) {

          case 72: // h

          hemiLight.visible = !hemiLight.visible;
          break;

          case 68: // d

          dirLight.visible = !dirLight.visible;
          break;

        }

      }

      //

      function animate() {

        requestAnimationFrame( animate );

        render();
        stats.update();

      }

      function render() {


			// Try Animate Camera Along Spline
			var time = Date.now();
			var looptime = 20 * 1000;
			var t = ( time % looptime ) / looptime;
			var pos = tube.parameters.path.getPointAt( t );
			pos.multiplyScalar( scale );
			// interpolation
			var segments = tube.tangents.length;
			var pickt = t * segments;
			var pick = Math.floor( pickt );
			var pickNext = ( pick + 1 ) % segments;
			binormal.subVectors( tube.binormals[ pickNext ], tube.binormals[ pick ] );
			binormal.multiplyScalar( pickt - pick ).add( tube.binormals[ pick ] );
			var dir = tube.parameters.path.getTangentAt( t );
			var offset = 15;
			normal.copy( binormal ).cross( dir );
			// We move on a offset on its binormal
			pos.add( normal.clone().multiplyScalar( offset ) );
			splineCamera.position.copy( pos );
			cameraEye.position.copy( pos );
			// Using arclength for stablization in look ahead.
			var lookAt = tube.parameters.path.getPointAt( ( t + 30 / tube.parameters.path.getLength() ) % 1 ).multiplyScalar( scale );
			// Camera Orientation 2 - up orientation via normal
			if ( !lookAhead ) lookAt.copy( pos ).add( dir );
			splineCamera.matrix.lookAt(splineCamera.position, lookAt, normal);
			splineCamera.rotation.setFromRotationMatrix( splineCamera.matrix, splineCamera.rotation.order );
			cameraHelper.update();
			renderer.render( scene, animation === true ? splineCamera : camera );
		}

    </script>
