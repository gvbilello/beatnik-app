<script type="x-shader/x-vertex" id="vertexShader">



    varying vec3 vWorldPosition;

    void main() {

      vec4 worldPosition = modelMatrix * vec4( position, 1.0 );
      vWorldPosition = worldPosition.xyz;

      gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

    }

</script>

<script type="x-shader/x-fragment" id="fragmentShader">

  uniform vec3 topColor;
  uniform vec3 bottomColor;
  uniform float offset;
  uniform float exponent;

  varying vec3 vWorldPosition;

  void main() {

    float h = normalize( vWorldPosition + offset ).y;
    gl_FragColor = vec4( mix( bottomColor, topColor, max( pow( max( h , 0.0), exponent ), 0.0 ) ), 1.0 );

  }

</script>

<script id="space-record-script">
$( document ).ready(function() {

      var bg = document.body.style;

      audioSrc.connect(analyser);
      audioSrc.connect(ctx.destination);
      var frequencyData = new Uint8Array(analyser.frequencyBinCount)
      analyser.getByteFrequencyData(frequencyData)

      // three.js globals
      var particlesArray = []
      var camera, scene, renderer, tick = 0,  clock = new THREE.Clock(true),
          geometry, controls, material, options, spawnerOptions, particleSystem;

      function visualSetup() {
        //getting correct sizing based on the browser window (more adaptable)
        var W = window.innerWidth, H = window.innerHeight;

        renderer = new THREE.WebGLRenderer( { antialias: true });

        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize( W, H );

        renderer.gammaInput = true;
        renderer.gammaOutput = true;

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.renderReverseSided = false;

        $("div#pseudo-body").append( renderer.domElement ); //the renderer's dom friendly copy
        //gets added to the DOM so we can actually see things happen.
        // camera setup ========================================
        camera = new THREE.PerspectiveCamera( 30, window.innerWidth / window.innerHeight, 1, 5000);
        camera.position.set(0, 0, 10);
        // =====================================================
        scene = new THREE.Scene();

        scene.fog = new THREE.Fog( 0xffffff, 1, 5000 );
        scene.fog.color.setHSL( 0.6, 0, 1 );
        camera.lookAt(scene.position);
        // The GPU Particle system extends THREE.Object3D, and so you can use it
        // as you would any other scene graph component.	Particle positions will be
        // relative to the position of the particle system, but you will probably only need one
        // system for your whole scene
        particleSystem = new THREE.GPUParticleSystem({
          maxParticles: 250000
        });
        scene.add( particleSystem);

        options = {
          position: new THREE.Vector3(),
          positionRandomness: .3,
          velocity: new THREE.Vector3(),
          velocityRandomness: .1,
          color: 0xaa88ff,
          colorRandomness: .2,
          turbulence: .5,
          lifetime: 2,
          size: 5,
          sizeRandomness: 1
        };
        spawnerOptions = {
          spawnRate: 18000,
          horizontalSpeed: 1.5,
          verticalSpeed: 1.25,
          timeScale: 0.5
        }

        // setup controls
        controls = new THREE.TrackballControls(camera, renderer.domElement);
        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 2.2;
        controls.panSpeed = 1;
        controls.dynamicDampingFactor = 0.3;

    ///////////background particles/////////////

      backGroundies = new THREE.Geometry();
      for ( i = 0; i < 2000; i ++ ) {
        var vertex = new THREE.Vector3();
        vertex.x = 1000 * Math.random() - 500;
        vertex.y = 1000 * Math.random() - 500;
        vertex.z = 1000 * Math.random() - 500;
        backGroundies.vertices.push( vertex );
      }
      material = new THREE.ParticleBasicMaterial( { size: 1, sizeAttenuation: false, transparent: true } );
      material.color.setHex( 0xffffff );
      particles = new THREE.ParticleSystem( backGroundies, material );
      particles.sortParticles = true;
      scene.add( particles );
      particlesArray.push( particles );


    ///////////    lighting     /////////////

        hemiLight = new THREE.HemisphereLight( 0xffffff, 0xffffff, 0.6 );
        hemiLight.color.setHSL( 0.6, 1, 0.5);
        hemiLight.groundColor.setHSL( 0.86, 0.93, 0.1 );
        hemiLight.position.set( 0, 500, 0 );
        scene.add( hemiLight );

        var dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
        dirLight.position.set( -1, 0.75, 1 );
        dirLight.position.multiplyScalar( 50);
        dirLight.name = "dirlight";
        // dirLight.shadowCameraVisible = true;

        dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
        dirLight.color.setHSL( 0.1, 1, 0.95 );
        dirLight.position.set( -1, 1.75, 1 );
        dirLight.position.multiplyScalar( 50 );
        scene.add( dirLight );

        dirLight.castShadow = true;

        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;

        var d = 50;

        dirLight.shadow.camera.left = -d;
        dirLight.shadow.camera.right = d;
        dirLight.shadow.camera.top = d;
        dirLight.shadow.camera.bottom = -d;

        dirLight.shadow.camera.far = 3500;
        dirLight.shadow.bias = -0.0001;

        // GROUND

        var groundGeo = new THREE.PlaneBufferGeometry( 10000, 10000 );
        var groundMat = new THREE.MeshPhongMaterial( { color: 0xffffff, specular: 0x050505 } );
        groundMat.color.setHSL( 0, 1, 0.15 );

        var ground = new THREE.Mesh( groundGeo, groundMat );
        ground.rotation.x = -Math.PI/2;
        ground.position.y = -33;
        scene.add( ground );

        ground.receiveShadow = true;

        // SKYDOME

        var vertexShader = document.getElementById( 'vertexShader' ).textContent;
        var fragmentShader = document.getElementById( 'fragmentShader' ).textContent;
        var uniforms = {
          topColor:    { value: new THREE.Color( 0x0173ff ) },
          bottomColor: { value: new THREE.Color( 0xff9c00 ) },
          offset:      { value: 33 },
          exponent:    { value: 0.6 }
        };
        uniforms.topColor.value.copy( hemiLight.color );

        scene.fog.color.copy( uniforms.bottomColor.value );

        var skyGeo = new THREE.SphereGeometry( 4000, 32, 15 );
        var skyMat = new THREE.ShaderMaterial( { vertexShader: vertexShader, fragmentShader: fragmentShader, uniforms: uniforms, side: THREE.BackSide } );

        var sky = new THREE.Mesh( skyGeo, skyMat );
        scene.add( sky );


        window.addEventListener('resize', onWindowResize, false);
        document.addEventListener( 'keydown', onKeyDown, false );
       }

       function onWindowResize() {
         camera.aspect = window.innerWidth / window.innerHeight;
         camera.updateProjectionMatrix();

         renderer.setSize(window.innerWidth, window.innerHeight);
       }

       function onKeyDown ( event ) {

         switch ( event.keyCode ) {

           case 72: // h

           hemiLight.visible = !hemiLight.visible;
           break;

           case 68: // d

           dirLight.visible = !dirLight.visible;
           break;

         }

       }

      function draw() {
        requestAnimationFrame( draw );

        controls.update();

        try {
          analyser.getByteFrequencyData(frequencyData)
        }
        catch(err) {
          frequencyData = [0]
        }


        freqSum = frequencyData.reduce(function(a, b) {
          return a + b;
        }, 0);

        // console.log(frequencyData);

        var delta = clock.getDelta() * spawnerOptions.timeScale;
              			tick += delta;
              			if (tick < 0) tick = 0;
              			if (delta > 0) {
                      analyser.getByteFrequencyData(frequencyData)
                      options['positionRandomness'] = frequencyData[0] / 256
                      options['velocityRandomness'] = frequencyData[0] / 256
                      options['size'] = ( frequencyData[0] / 16 ) + 10
                      options['turbulence'] = frequencyData[0] / 256
              				options.position.x = Math.sin(tick * spawnerOptions.horizontalSpeed);
              				options.position.y = Math.sin(tick * spawnerOptions.verticalSpeed);
              				options.position.z = Math.sin(tick * spawnerOptions.horizontalSpeed + spawnerOptions.verticalSpeed) * 5;
                      renderer.setClearColor(scene.fog.color);
                      camera.lookAt(options.position);
                      for (var x = 0; x < spawnerOptions.spawnRate * delta; x++) {
              					// Yep, that's really it.	Spawning particles is super cheap, and once you spawn them, the rest of
              					// their lifecycle is handled entirely on the GPU, driven by a time uniform updated below
              					particleSystem.spawnParticle(options);
              				}
              			}
              			particleSystem.update(tick);
              			render();
              		}
              		function render() {
              			renderer.render(scene, camera);
                  }

      visualSetup();
      draw();

});
</script>
